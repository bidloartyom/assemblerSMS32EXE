mov dl, a0 ; указываем реестру дл €чейку а0, все €чейки до с0 не вывод€т значение на wyswitlacz VDU
mov bl, 0 ; указываем bl 0

start:

in 00 ; считываем знак с клавиатуры в реестр al
mov [dl],al ; сохран€ем этот знак в оперативной пам€ти

cmp dl,af ; сравниваем дошел ли реестр дл до €чейки аф котора€ €вл€етс€ концом строки а
jz wyswietl ; переходим к выводу начинающий обратный вывод от €чейки в которой 0D

cmp al,0D ; сравниваем был ли этот нажатый знак enter 
jz wyswietl ; переходим к выводу начинающий обратный вывод от €чейки в которой 0D

inc dl ; переходим в следующую €чейку дл - была а0 стала а1

jmp start ; принудительный прыжок в старт

wyswietl: ; цикл дл€ вывода знаков

mov bl, d0 ; присваеваем реестру бл €чейку с0 котора€ выводит знаки
mov cl, 9f ; устанавливаем адрес конца программы, чтобы сравнивать и останавливать вывод если указать а0, то он не выведет первый введеный знак
dec dl ; чтобы не выводило enter то есть 0D то есть пробел в высветлачу
ret:

mov al, [dl] ; считываем знак записанный в €чейке реестра цл в реестр ал
mov [bl], al ; выводим этот знак в €чейку котора€ указана в реестре бл
inc bl ; переходим к следующей €чейке дл€ вывода данных
dec dl ; переходим к предидущей €чейке дл€ считывани€ данных
cmp dl, cl ; сравниваем была ли эта €чейка конечной или нет  с помощью реестра цл в котором указан адрес а0 - начало знаков
jz endl; если это была конечна€ €чейка записанных знаков то перепрыгиваем в конец программы

jmp ret; если не конечна€ €чейка то снова выводим следующий знак
endl:
end


